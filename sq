#!/usr/bin/env python
import click
import os
import re
import subprocess
import sys


TF_CONTAINER = "tf"


@click.group(help="Studio Quixote cli commands.")
def cli():
    pass


@cli.group(help="Local (docker) commands.")
def dev():
    pass


@cli.group(help="ffmpeg commands.")
def ffmpeg():
    pass


def _is_mp4(ctx, param, value):
    if not re.match(r"\.mp4$", value):
        raise click.BadParameter("Output file must be .mp4")


def _run_command(cmd, error_message=None, capture_output=False, hide_command=False):
    # hide_command can be used to reduce the amount of output
    if not hide_command:
        click.secho("\n>> Running: {}\n".format(cmd), fg="green")
    if error_message:
        if capture_output:
            raise "capture_output + error_message cannot both \
                   be used, because subprocess.call does not \
                   allow capture_output"

        code = subprocess.call(cmd, shell=True)
        if code != 0:
            click.secho(error_message, fg="red")
            sys.exit(code)
    else:
        try:
            return subprocess.run(
                cmd, shell=True, check=True, capture_output=capture_output
            )
        except subprocess.CalledProcessError as e:  # remote commands sometimes throw this
            return subprocess.CompletedProcess(cmd, e.returncode, stderr=e.output)


def _env_vars(inherit_env):
    if not inherit_env:
        return ""
    prefix = re.compile(r"^SQ__")
    args = []
    for k, v in os.environ.items():
        if re.match(prefix, k):
            args.append('-e {0}="${1}"'.format(re.sub(prefix, "", k), k))
    return " ".join(args)


@dev.command(help="Start bash in docker container, inheriting SQ__ prefixed env vars.")
@click.option(
    "--no-inherit-env", is_flag=True, help="Do NOT inherit FA_DEV__ env vars."
)
def bash(no_inherit_env):
    _run_command(
        "docker exec {0} -it {1} bash".format(
            _env_vars(not no_inherit_env), TF_CONTAINER
        )
    )


@ffmpeg.command(help="Convert to mp4 for import to DaVinci Resolve.")
@click.argument("input_filename", type=click.Path(exists=True))
@click.argument("output_filename", required=True, type=str, callback=_is_mp4)
def resolve_mp4(input_filename, output_filename):
    _run_command(
        f"""
        ffmpeg -i "{input_filename}" \
        -c:v libx264 -pix_fmt yuv420p -crf 16 \
        -force_key_frames 'expr:gte(t,n_forced/2)' -bf 2 \
        -vf yadif -use_editlist 0 \
        -movflags +faststart \
        -c:a aac -q:a 1 \
        -ac 2 -ar 48000 \
        -f mp4 "{output_filename}"
        """
    )


if __name__ == "__main__":
    cli()
